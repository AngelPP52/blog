# 背景

最近团队在建设可视化埋点系统，其中点选标记元素等交互最终决定使用浏览器插件的方式实现，于是开始了一段浏览器插件开发的探索之旅。另外，为了补全前端开发技能，学习开发浏览器插件是很重要的一件事。

此文会总结一下各类 API 的用法，并且以埋点插件作为 demo 来帮助讲述如何帮助大家快速开始一个浏览器插件开发的工作。

# 正文

## 核心内容

### Manifest

`Manifest` 文件是浏览器插件的核心内容，我们可以从 `manifest.json` 文件中读取大部分谷歌插件支持的 API。

```json
{
  // 必需字段
  "manifest_version": 3, //  指定 manifest 字段的 Version 2 或者 Version 3。
  "name": "My Extension",  // 插件名。
  "version": "versionString", // 插件的版本号。

  // 常用字段
  "action": {...}, // 控制插件 图标 按钮，对应 API：chrome.action。
  "default_locale": "en", // 
  "description": "A plain text description", // 插件描述，在浏览器扩展页面（chrome://extensions/）能看到。
  "icons": {...}, // 指定插件 图标 按钮，支持 128*128，48*48，16*16 的分辨率。

  // 可选字段
  "action": ...,
  "author": ...,
  "automation": ...,
  "background": { // 使用 service_worker 的后台工作线程，可以在这里监听浏览器事件：导航到新页面、移除书签、关闭选项卡等。
    // Required
    "service_worker":
  },
  "chrome_settings_overrides": {...},
  "chrome_url_overrides": {...},
  "commands": {...},
  "content_capabilities": ...,
  "content_scripts": [{...}], // 运行于网页上下文的脚本，可以在这里调用 DOM API，操作页面的变化等。
  "content_security_policy": "policyString",
  "converted_from_user_script": ...,
  "current_locale": ...,
  "declarative_net_request": ...,
  "devtools_page": "devtools.html", // 可以为 chrome devtools 添加功能
  "differential_fingerprint": ...,
  "event_rules": [{...}], // 配置一些规则，根据页面内容/行为采取不同行为
  "externally_connectable": {
    "matches": ["*://*.example.com/*"]
  },
  "file_browser_handlers": [...],
  "file_system_provider_capabilities": {
    "configurable": true,
    "multiple_mounts": true,
    "source": "network"
  },
  "homepage_url": "http://path/to/homepage",
  "host_permissions": [...],
  "import": [{"id": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"}],
  "incognito": "spanning, split, or not_allowed",
  "input_components": ...,
  "key": "publicKey",
  "minimum_chrome_version": "versionString",
  "nacl_modules": [...],
  "natively_connectable": ...,
  "oauth2": ...,
  "offline_enabled": true,
  "omnibox": {
    "keyword": "aString"
  },
  "optional_permissions": ["tabs"],
  "options_page": "options.html", // 可以提供一个选项页面，自定义插件的行为，打开的是一个新的页面
  "options_ui": { // 同 options_page，打开的是一个弹出式页面
    "chrome_style": true,
    "page": "options.html"
  },
  "permissions": ["tabs"],
  "platforms": ...,
  "replacement_web_app": ...,
  "requirements": {...},
  "sandbox": [...],
  "short_name": "Short Name",
  "storage": {
    "managed_schema": "schema.json"
  },
  "system_indicator": ...,
  "tts_engine": {...},
  "update_url": "http://path/to/updateInfo.xml", // 插件自动更新策略
  "version_name": "aString",
  "web_accessible_resources": [...]
}
```

### action/browser_action

### background

### content_scripts

### options_page/options_ui

### homepage_url

### update_url

## 核心 API

### chrome.action/chrome.browserAction

### chrome.runtime/chrome.tabs



### chrome.contextMenus



## 功能开发

### 消息传递

> 扩展程序和内容脚本间的通信使用消息传递的方式。两边均可以监听另一边发来的消息，并通过同样的通道回应。消息可以包含任何有效的 JSON 对象（null、boolean、number、string、array 或 object）。

#### 一次性的简单请求

主要是`runtime.sendMessage`或`tabs.sendMessage` 方法。

**1、发送方**

在`内容脚本`中发送请求，或从`扩展程序`向`内容脚本`发送请求。

```js
chrome.runtime.sendMessage({greeting: "您好"}, function(response) {
  console.log(response.farewell);
});
```

向`指定标签页`中的内容脚本中发送请求。

```js
chrome.tabs.query({active: true, currentWindow: true}, function(tabs) {
  chrome.tabs.sendMessage(tabs[0].id, {greeting: "您好"}, function(response) {
    console.log(response.farewell);
  });
});
```

**2、接收方**

```js
chrome.runtime.onMessage.addListener(
  function(request, sender, sendResponse) {
    console.log(sender.tab ?
                "来自内容脚本：" + sender.tab.url :
                "来自扩展程序");
    if (request.greeting == "您好")
      sendResponse({farewell: "再见"});
  });
```

#### 长连接的请求

主要是`runtime.connect`或`tabs.connect`方法。

**1、发送方**

在`内容脚本`中发送请求，或从`扩展程序`向`内容脚本`发送请求。

**建立连接后，两端都将得到一个 `runtime.Port`对象，用来通过建立的连接发送和接收消息。**

```js
var port = chrome.runtime.connect({name: "敲门"});
port.postMessage({joke: "敲门"}); // 发送消息
port.onMessage.addListener(function(msg) { // 接收消息
  if (msg.question == "是谁？")
    port.postMessage({answer: "女士"});
  else if (msg.question == "哪位女士？")
    port.postMessage({answer: "Bovary 女士"});
});
```

向`指定标签页`中的内容脚本中发送请求，使用`tabs.connect`替换上述的`runtime.connect`。

**2、接收方**

设置一个`runtime.onConnect`事件监听器，监听发送方调用 connect() 后，建立连接并得到一个`runtime.Port`对象。

```js
chrome.runtime.onConnect.addListener(function(port) {
  console.assert(port.name == "敲门");
  port.onMessage.addListener(function(msg) {
    if (msg.joke == "敲门")
      port.postMessage({question: "是谁？"});
    else if (msg.answer == "女士")
      port.postMessage({question: "哪位女士？"});
    else if (msg.answer == "Bovary 女士")
      port.postMessage({question: "我没听清楚。"});
  });
});
```

**3、断开连接**

其中一端监听`runtime.Port.onDisconnect`事件，当连接的另一端调用`runtime.Port.disconnect`或包含该端口的页面已结束（例如标签页转到了另一个页面）时，对于每一个端口确保都会发生一次该事件。

## 参考

- https://crxdoc-zh.appspot.com/extensions/messaging