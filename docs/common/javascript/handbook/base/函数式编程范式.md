## 函数式编程范式

在前端的编程范畴里，“不依赖外部环境”几乎不可能，我们总是不可避免第使用 DOM 操作、AJAX 等状态随时会变化的东西。所以我们需要更加强大的技术来干这些“脏活”

### 特性

- 纯函数：对于相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用，也不依赖外部环境的状态
- 柯里化：传递函数的一部分参数，返回一个函数处理剩余的参数
- 组合函数：比如`compose`，解决函数嵌套问题，`f1(f2(f3))`这种代码比较丑陋，优化以后变成`compose(f1,f2,f3)(...args)`
- Ponit Free：不要产出没必要的中间变量。过于要求`Ponit Free`，往往会让代码越变越多，看你的取舍了
- 声明式与命令式：命令式指代码按照一条又一条指令去执行某些动作，个中一般涉及到很多繁杂的细节，例如`for`循环；声明式指一条表达式完成我们需要的业务，例如`计数器迭代`，`数组处理`等，无副作用的函数，不需要考虑内部实现

### 容器、Functor

容器为函数式编程里普通的变量、对象、函数提供了一层极其强大的外衣，赋予他们不同的特性。

`Functor(函子)`是实现了 map 并遵守一些特定规则的容器类型

### 错误处理、Either

`try...catch/throw`并不是纯的，它从外部接管了我们的函数，并且这个函数出错时抛弃了它的返回值，这不是我们期望的函数式行为。

`Promise`就是对内部的错误进行集中处理`catch`

对于函数式编程，我们也可以利用`Promise`这一个特性，如果运行正确就返回正确的结果，如果错误，就返回一个描述错误的结果

### IO

惰性求值：只有当我们真正需要这个值的时候，才开始求值

```js
var IO = function(f){
    this._value = f;
}
IO.prototype.map = function(f){
    return new IO(compose(f, this._value))
}
var io_document = new IO(_ => window.document);
io_document.map(function(doc){return doc.title}); // 返回的是一个函数，只有真正调用的时候，才会求值，把这些不纯的操作带来的复杂性和不可维护性推到 IO 的调用者身上
```

## 函数式编程的引用

### React

> 函数式和状态机，Redux 将核心逻辑抽象成一个函数 reducer

RxJS