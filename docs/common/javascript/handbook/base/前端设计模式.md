> 参考《JavaScript设计模式》一书

# 创建型设计模式

通过某种方式控制对象的创建来避免基本对象创建时可能导致设计上的问题或增加设计上的复杂度。

## 工厂模式

- 简单工厂模式：又叫静态工厂方法，由一个工厂对象决定创建某一种产品对象类的实例

通过创建一个新对象然后包装增强其属性和功能，然后调用工厂函数返回这个对象。通过简单工厂来创建一些对象，可以让这些对象共用一些资源而又私有一些资源，这是一种很不错的实践，不过它的使用场景也就限制在创建单一对象

```js
function createBook(name, time, type){
    var o = new Object();
    o.name = name;
    o.time = time;
    o.type = type;
    o.getName = function(){
        return this.name;
    }
    if(type === 'Book1'){
        // Book1的差异部分
    }
    if(type === 'Book2'){
        // Book2的差异部分
    }
    ...
    return o;
}
```

> 如果是多类的情况下，除了添加新类，还得去修改工厂方法，修改两个地方

- 工厂方法模式：通过对产品类的抽象使其创建业务主要负责用于创建多类产品的实例

适合创建多类对象，每次添加新类时，只需要修改工厂方法即可。这样工厂方法对象在创建对象的方式避免了使用者与对象类之间的耦合，用户不必担心创建该对象的具体类，只需调用工厂方法即可

```js
var Factory = function(type, content){
    if(this instanceOf Factory){
        var s = new this[type](content);
        return s;
    }else {
        return new Factory(type, content);
    }
}
Factory.prototype = {
    Java: function(){},
    JavaScript: function(){},
    UI: function(){},
    php: function(){}
    // ... 以后只需要在这后面添加新类就可以了
}
```

- 抽象工厂模式：通过对类的工厂抽象使其业务用于对产品类簇的创建，而不负责创建某一类产品的实例

 抽象工厂模式创建出来的结果**不是一个真实的对象实例，而是一个类簇，它制定了类的结构**，这也就区别于**简单工厂模式创建单一对象**，**工厂方法模式创建多类对象**

```js
var VehicleFactory = function(subType, superType){
    if(typeof VehicleFactory[superType] === 'function'){
		function F(){};
        F.prototype = new VehicleFactory[superType]();
        subType.constructor = subType;
        subType.prototype = new F();
    }else {
        throw new Error('未创建该抽象类')
    }
}
VehicleFactory.Car = function(){
    this.type = 'Car';
}
VehicleFactory.Car.prototype = {
    getPrice: function(){
        return new Error('抽象方法不能调用');
    },
    getSpeed: function(){
        return new Error('抽象方法不能调用')
    }
}
// ... 可以定义定义更多抽象类
// 以下是实现：
var BWM = function(price, speed){
    this.price = price;
    this.speed = speed;
}
VehicleFactory(BWM, 'Car');
BWM.prototype.getPrice = function(){
    return this.price;
}
BWM.prototype.getSpeed = function(){
    return this.speed;
}
```

## 单例模式

单例模式：又被称为单体模式，是只允许实例化一次的对象类。有时我们也**用一个对象来规划一个命名空间**，井井有条地管理对象上的属性和方法

单例模式的代码都模块分明，且对象内部可以定义无法修改的静态变量（JavaScript天生没有这种语法，通过自执行函数返回对象作为命名空间的方式，这个对象的属性才是对外暴露的内容）

```js
var Conf = (function(){
    var conf = {
        MAX_NUM: 100,
        MIN_NUM: 1,
        COUNT: 1000
    }
    // 返回取值器对象，外部模块无法修改conf对象的属性
    return {
        get: function(name){
            return conf[name] ? conf[name] : null;
        }
    }
})();
console.log(Conf.get('MAX_NUM')); // 100

// 惰性单例 => 延迟执行
var LazySingle = function(){
    var _instance = null;
    function Single(){
        // 这里面定义私有属性和方法
        return {
            publicMethod: function(){},
            publicProperty: '1.0'
        }
    }
    return function(){
        // 如果是延迟执行，只创建一次单例
        if(!_instance){
            _instance = new Single();
        }
        // 返回单例
        return _instance;
    }
}
console.log(LazySingle().publicProperty); // '1.0'
```

# 结构型设计模式

关注于如何将类或对象组合成更大、更复杂的结构，以简化设计。

## 外观模式

外观模式：为一组复杂的子系统接口**提供一个更高级的统一接口**，通过这个接口使得对子系统接口的访问更容易。在JavaScript中有时也会用于对底层结构兼容性做统一封装来简化用户使用

> onclick是DOM0级事件，重复定义的话会覆盖原来的绑定
>
> addEventListener是DOM2级事件，可以定义多个回调，但是IE9以下不支持，所以可以使用attachEvent

```js
// 外观模式实现
function addEvent(dom, type, cb){
    if(dom.addEventListener){
        dom.addEventListener(type, cb, false);
    }else if(dom.attachEvent){
		dom.attachEvent('on' + type, cb);
    }else{
        dom['on' + type] = cb;
    }
} 
```

> 除了可以简化底层接口复杂性，也可以解决浏览器兼容性问题

```js
var getEvent = function(event){
    // 标准浏览器下event IE下window.event
    return event || window.event;
}
var getTarget = function(event){
    var event = getEvent(event);
    // 标准浏览器下event.target IE下event.srcElement
    return event.target || event.srcElement;
}
var preventDefault = function(event){
    var event = getEvent(event);
    if(event.preventDefault){ // 标准浏览器
        event.preventDefualt();
    }else{ // IE浏览器
        event.returnValue = false;
	}
}
```

## 代理模式

代理模式：由于一个对象不能直接引用另一个对象，所以需要通过**代理对象**在这两个对象之间起到中介的作用

> 浏览器对不同域名，不同端口号，不同协议，域名与域名对应的IP，主域与子域，子域与子域，都限制了（同源策略）
>
> 1. 站长统计
>
>    通过img之类标签通过src属性可以向其他域下的服务器发送请求，但只能是get请求，而且是单向的，不会有响应数据
>
> 2. JSONP
>
>    通过script标签
>
> 3. 代理模板
>
>    通过iframe内嵌框架
>
> 4. 预览图片
>
>    使用一张预览图片来代理原图片，等原图片加载完成再替换。这样，如果页面中有很多图片，对首屏加载时间收益是很大的

代理模式可以解决系统之间的耦合度以及系统资源开销大的问题，通过代理对象可保护被代理对象，使被代理对象拓展性不受外界的影响。也可通过代理对象解决某一交互或者某一需求中造成的大量系统开销

## 适配器模式

适配器模式：将一个类（对象）的接口（方法或者属性）转化成另外一个接口，以满足用户需求，使类（对象）之间接口的不兼容问题通过适配器得以解决。

**适配异类框架**：引入相似框架，可以互相适配

```js
window.A = A = JQuery; // 如果两个框架差异太大，适配器就要复杂很多了
```

**参数适配器**：参数太长了，使用一个对象代替参数列表

```js
function doSomeThing(obj){
    var _adapter = { // 默认参数对象
        ...
    };
    for(var i in _adapter){
        _adapter[i] = obj[i] || _adapter[i];
    }
    
}
```

**服务器端数据适配**

```js
function ajaxResponseAdapter(data){
    return {data['key1'], data['key2'], data['key3']};
}
```

## 装饰者模式

装饰者模式：在不改变原对象的基础上，通过**对原对象进行包装拓展**（添加属性或者方法）使原有对象可以满足用户的更复杂需求。

与适配器模式相比，适配器模式在新值的方法中要调用原有的方法，需要了解原有方法实现的具体细节。装饰者模式则不需要了解原有方法实现的具体细节。

```js
// 装饰者
var decorator = fucntion(input, fn){
    var input = document.getElementById(input);
    if(typeof input.onclick === 'function'){
        var oldClickFn = input.onclick;
        input.onclcik = function(){
            oldClickFn();
            fn();
        }
    }else{
        input.onclick = fn;
    }
}
```

# 行为型设计模式

用于不同对象之间职责划分或算法抽象，不仅涉及类和对象，还涉及类和对象之间的交流模式。

## 策略模式

策略模式：将定义的一组算法封装起来，将其互相之间可以替换。封装的算法具有一定独立性，不会随客户端变化而变化

策略模式不需要管理状态，状态间没有依赖关系，策略之间可以互相替换，在策略对象内部保存的是互相独立的一些算法

> 1. 策略对象
> 2. 缓冲函数 - jQuery的animate动画函数
> 3. 表单验证

## 迭代器模式

迭代器模式：在不暴露对象内部结构的同时，可以顺序地访问聚合对象内部的元素

```js
// 迭代器
var Iterator = function(items, container){
    var container = container && document.getElementById(container) || document,
	    items = container.getElementsByTagName(items),
    	length = items.length;
    	index = 0;
    var splice = [].splice;
    return {
        // 获取第一个元素
        first: function(){},
        // 获取最后一个元素
        second: function(){},
        // 获取前一个元素
        pre: function(){},
        // 获取后一个元素
        next: function(){},
        // 获取某一个元素
        get: function(num){},
        // 对每一个元素执行某一个方法
        dealEach: function(fn){},
        // 对某一个元素执行某一个方法
        dealItem: function(num, fn){}，
        // 排他方式处理某一个元素
        exclusive: function(num, allFn. numFn){}
    }
}
```

另外，还有数组迭代器，对象迭代器，同步变量迭代器...

```js
// 同步变量迭代器：解决对象属性取值时一层一层地做安全验证的麻烦，var c = A && A.b && A.b.c
var Getter = function(target, key){
    if(!target){
        return undefined;
    }
    var result = target;
    key = key.split('.');
    for(var i = 0, len = key.length; i < len; i++){
		if(result[key[i]] !== undefined){
			result = result[key[i]];
        }else{
            return undefined;
        }
    }
    return result;
}
console.log(Getter({client: {user: {username: 'admin'}}}, 'client.user.username')); // 'admin'
```

## 观察者模式

观察者模式：又被称作发布-订阅模式或消息机制，定义了一种依赖关系，解决了主体对象与观察者之间功能的耦合

## 中介者模式

中介者模式： 通过**中介者对象封装一系列对象之间的交互**，使对象之间不再互相引用，降低他们之间的耦合。有时中介者对象也可改变对象之间的交互。

与外观模式的封装特性相比，外观模式封装的目的是为了提供更简单的易用接口，而不会添加其他功能。中介者对多个对象交互进行封装，都在中介者内部。

与观察者模式相比，观察者模式的订阅者是双向的，既可以是消息的发布者，也可以是消息的订阅者。中介者模式订阅者是单向的，只是消息的订阅者，消息统一由中介者对象发布，所有订阅者对象间接地被中介者管理。

```js
// 中介者模式，订阅和发布消息的中心
var Mediator = fucntion(){
    var _msg = {};
    return {
		register: function(type, action){ // 订阅信息
            if(_msg[type]){
				_msg[type].push(action);
            }else{
                (_msg[type] = []).push(action);
            }
        },
        send: function(type, action){ // 发布消息
			if(_msg[type]){
                for(var i = 0, len = _msg[type].length; i < len; i++){
                    _msg[type][i] && _msg[type][i]();
                }
            }
        }
    }
}

// 显示/隐藏导航小组件：通过中介者对象订阅和发布显示/隐藏状态，然后通过回调来控制组件样式
var showHideNavWidget = function(mod, tag, showOrHide){
    var mod = document.getElementById(mod);
    var tag = document.getElementsByTagName(tag);
    showOrHide = (!showOrHide || showOrHide === 'hide') ? 'hidden' : 'visibility';
    for(var i = tag.length - 1; i >= 0; i++){
        tag[i].style.visibility = showOrHide;
    }
}
```

## 访问者模式

访问者模式：针对于对象结构中的元素，定义在不变化该对象的前提下访问结构中元素的新方法。精髓就是**改变函数的作用域（this的指向）**

> 回看外观模式中的第一个代码案例，在IE浏览器中，回调函数的this并没有指向事件源对象dom，而是window。为了解决IE这种问题，可以使用访问者模式

```js
// 最后一个参数是自定义数据，执行回调时就能拿到这个自定义数据
function bindIEEvent(dom, type, cb, data){
    var data = data || {}；
    dom.attachEvent('on' + type, function(e){
        // 回调中的this指向了事件源对象dom，e是事件对象，data是自定义数据
        cb.call(dom, e, data);
    })
}
```

> 类数组，定义对象访问器

```js
var Visitor = (function(){
    return {
        splice: function(){
            var args = Array.protorype.splice.call(arguments, 1);
            return Array.prototype.splice.apply(arguments[0], args);
        },
        push: function(){
            var len = arguments[0].length || 0;
            var args = this.splice(arguments, 1);
            arguments[0].length = len + arguments.length - 1;
            return Array.
        }
    }
})();
```

