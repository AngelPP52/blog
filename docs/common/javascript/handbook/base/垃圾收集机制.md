## 垃圾收集机制

垃圾收集机制，一般有两种策略：标记清除和引用计数。

### 标记清除

概念：

当变量进入环境时（例如在函数中声明一个变量），就将这个变量标记为“进入环境”（理论上，不会释放进入环境的变量的内存，因为环境中有可能引用到），当变量离开环境时，将其标记为“离开环境”。

回收过程：

垃圾收集器在运行的时候会**给存储在内存中的所有变量加上标记**（不同的引擎，标记方式不一样）。然后，他会**去掉环境中的变量以及被环境中的变量引用的变量的标记**。而在此之后**再被加上标记的变量将被视为准备删除的变量**，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。

### 引用计数

回收过程：

跟踪记录每一个值被引用的次数。**当声明了一个变量并将一个引用类型赋给了该变量时，则这个值的引用次数就是1。如果同一个值又被赋给了另一个变量，则该值的引用次数加1**。相反，**如果包含对这个值引用的变量又取得另一个值，则这个值得引用次数减1**。当这个值得引用次数为0时，则说明没有办法再访问这个值了，因而垃圾收集器就会把这个变量销毁掉，并且回收其占用的空间。

### IE中的垃圾回收

IE中，BOM和DOM中的对象就是使用C++以COM对象的形式实现的，而COM对象的垃圾收集机制采取的是引用计数策略。而IE的Javascript引擎是使用标记清除策略来实现的。所以IE中只要涉及COM对象，就会存在循环引用的问题（这个时候就需要手动断开引用了）。

### 总结

尽管Javascript引擎自带的垃圾回收机制，可以满足大部分内存管理的问题，但也无法避免因为程序问题，导致代码中国又很多没必要的数据无法被回收。这个时候，应该手动**解除引用**。解除引用的真正作用就是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。