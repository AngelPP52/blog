# 《你不知道的 js - 上卷》

[^作者]: AngelPP
[^日期]: 2020-08-16

## 作用域和闭包

- 引擎

  负责 js 程序的编译以及执行过程

- 编译器

  负责语法分析以及代码生成等工作

- 作用域

  负责收集并维护所有声明的变量组成的一系列查询

> `赋值操作`是如何进行的？
>
> var a=2

- `声明阶段` - **编译器**询问当前作用域是否存在 a，如果存在，继续进行编译，否则会在当前作用域声明一个变量
- `赋值阶段` - **引擎**询问当前作用域是否存在 a，如果存在，直接赋值，否则引擎会继续查找该变量，直到全局作用域，如果还是找不到，就会报一个异常（ReferenceError）

> `作用域查找`的两种方式？

- `LHS 查询` - 变量出现在赋值操作的左侧

  赋值操作的目标。如：变量赋值，调用函数的传递参数

- `RHS 查询` - 变量出现在赋值操作的右侧，**非左侧**

  赋值操作的源头（源值）。如：变量赋值，函数调用，调用函数的接收参数，引用变量

### 词法作用域

> 词法作用域的`查找规则`，**气泡**往上冒

- 从当前作用域开始查找，无法找到，就取上一级的作用域继续查找
- 作用域查找会在找到第一个匹配的标识符时停止
- 函数的词法作用域只由函数**被声明时所处的位置决定**

> `欺骗词法作用域`
>
> 似乎会导致性能下降

- eval 可以在用户写的代码处用程序生成代码并且运行，并且会**修改当前的词法作用域**，从而会"遮蔽"上级作用域的同名变量

  ```js
  function foo(str, a){
      eval(str);
      console.log(a, b); // 遮蔽全局作用域的 b
  }
  var b = 2;
  foo("var b = 3", 1); // 1,3
  ```

- with 避免重复引用一个对象的多个属性的快捷方式，将一个对象处理为词法作用域。但是，这个块内部正常的 var 并不会限制在这个块的作用域中，而是**被添加到 with 所处的作用域中**

  ```js
  function foo(obj){
      with(obj){
          a = 2;
      }
  }
  var o1 = {
      b: 2
  }
  foo(o1);
  console.log(o1.a); // undefined，并不会在 obj 中创建一个 a 属性
  console.log(a); // a 被泄露到全局作用上了！
  ```

### 函数作用域和块作用域

#### 函数作用域

- 属于这个函数的全部变量都可以在整个函数的范围内使用及复用（包括嵌套的作用域）
- 隐藏内部实现，私有属性和私有方法都是无法被外部访问的
- 规避冲突，避免同名标识符

> `函数表达式`和`函数声明`的区别？

- 他们的名称标识符都绑定在何处

  ```js
  // 函数声明
  // 可以在函数声明的作用域中，直接调用
  function foo(){
      //...
  }
  
  // 立即执行函数表达式
  // foo 只能在...所在的位置内部中被访问，外部作用域则不行，**避免了非必要的污染外部作用域**
  (function foo(){
      //...
  })()
  ```

> 匿名函数表达式，如作为回调参数的匿名函数表达式

> IFFE，立即执行函数表达式

#### 块作用域

> 变量的声明应该距离使用的地方越近越好，并最大限度地本地化

```js
// 这是一个为了风格更易读而伪装出的形式上的块作用域
if(true){
    var bar = 2; // **这个 bar 依然是属于外部作用域的**
}
```

> 典型的会形成块作用域的语法：`with`，`try/catch`，`let`，`const`

```js
if(true){
    { // <-- 明显的块
        console.log(bar); // ReferenceError!
        let bar = 2; // 使用 let 创建的块，**并且不会在块作用域中进行提升**
    }
}
```

> 闭包的形成可能会阻止所在作用域的垃圾回收（包括闭包没有引用的数据结构），但如果使用块作用域，可以有效避免这个问题，**块定义的内容完事就会销毁**

```js
function precess(data){
    //...
}
{ // 在这个块中定义的内容完事可以销毁
    let somData = {};
    process(somData);
}
btn.addEventListener("click", function(){
    //...
})
```

### 提升

> 变量和函数的所有**声明都会在任何代码被执行前首先被处理**
>
> 先有蛋（**声明**）后有鸡（**赋值**）
>
> **函数声明会被提升，函数表达式不会被提升**
>
> **函数优先**，函数会首先被提升，然后才是变量
>
> 出现在**后面的函数声明会覆盖前面的**

```js
foo(); // 1
var foo; // 变量 foo 会被函数 foo 覆盖
function foo(){ // 函数声明会被提升到 foo() 调用的前面，因此前面的 foo() 不会报错
    console.log(1);
}

foo = function(){
    console.log(2);
}
```

```js
foo(); // 3
var foo; // 变量 foo 会被函数 foo 覆盖
function foo(){ // 函数声明会被提升到 foo() 调用的前面，因此前面的 foo() 不会报错
    console.log(1);
}

foo = function(){
    console.log(2);
}

function foo(){
    console.log(3); // 会覆盖前面的同名函数声明
}
```

