**回答cli项目：**

是这样的，因为我们之前使用的是ng脚手架，使用起来不够灵活，如果业务场景稍微要求苛刻点，有些配置或者优化就很难实现。所以我当时就去了解了有没有其他打包工具，就接触了webpack。不过刚接触，我还远远不能自己写一个cli，甚至连使用，我都翻阅了很多文章才真正学习到，而且如果使用webpack打包一个ts框架项目，就不能像demo那样打包一个js文件那么简单。所以，为此，我去github上查了相关的项目，找到了一个最佳实践的项目，就是ng自己做的一个`angular-started`的案例，里面就有已经写好的配置，虽然能运行起来并且把一个ng6.0的项目跑起来，但是对于有些配置项吗，而且ng-cli与自定义webpack有啥区别呢，我是挺蒙的。带着疑问，我去读了webpack的源码，了解了webpack构建流程，loader和plugin的运作原理，还有如何写loader和plugin去解决自己的业务场景，其中，我加了一个plugin，就是去监听emit钩子，在所有代码块在发射到指定文件前，读取所有文件的字节，并且通过加密生成一个文件，这个文件就是最后需要的项目文件了。

总结：在这个过程中，尽管这个cli不是很强大，将webpack打包、dev server的功能组合到一起，通过命令行传递的参数也不是很多，但是已经能够解决当时的业务需求。最重要的，我学习到了基于发布订阅模式的tapable赋能了webpack，就是使其在构建流程中对外提供不同的钩子，开发者可以添加插件去增强打包的能力，而且webpack本身也是基于很多的插件来进行的。另外，我也了解了AST的原理，为什么ts项目、使用ES6语法的js项目，经过打包之后，能够直接在浏览器里面运行。实际上webpack已经不仅是一个打包工具，它更像是一个能让你放心使用新语法、使用新技术的工具，而且你还可以让他帮你做一些代码规范的工作，做polyfills兼容，做代码优化，图片优化，构建优化，减少一些人为的重复性工作，甚至一直在尽可能地帮开发者节约代码量。

**回答ts库项目：**

首先为什么需要封装这个的库。目的就是为了减少重复性的调用函数，由对字段的处理改为对整个对象统一处理，具体做法如下：

定义一种类型，用来装饰这些类，表示这是一个专门用于ws传输的类型，而且他的实例上都会两个解析方法：getDataFromBytes和toBytes

给这个类的字段，添加装饰器，说明这个字段在底层协议中代表的是什么类型：unit8或unit32甚至更复杂的类型

安装这个NPM包，就可以开箱使用了。

总结：虽然这个包不大，最难的也就是getDataFromBytes和toBytes两个方法了，需要对对象树进行遍历。但是能从重复机械性的工作中思考到最简便的方式，我觉得这种经验还挺宝贵的，因为我有点讨厌流水线味道很重的工作。而且这也让我又去重温了一遍TypeScript的特性，这对我理解ts+react、ts类库的项目也有很大的帮助，很多时候只要看类型声明文件，我就能大概知道类库的大概功能，直接就节约看js源代码的时间

**为什么我喜欢React**

- 基于MVC模式，代码组织好
- 合并事件，减少没必要的渲染成本，提高页面的性能
- 易学，没有太多花里胡哨的概念，基本懂个生命周期和路由组件和常用API就可以做项目了
- 逻辑复用性强，配合高阶组件使用更香
- 既可以使用类组件，也可以使用函数组件，对于那些喜欢函数式编程的人来说，看到函数就觉得亲切
- DOM DIF使React应用可以最小化进行重绘，避免不必要的渲染成本
- React Hook的引入，使函数式组件更具备活力
- 社区好，包括他对Redux的支持，现在比较成熟的saga、dva、umi都可以很不错的使用Redux的解决方案，另外还可以支持Mobx；组件库和工具库比较丰富，这样也可以避免很多重复性的造轮子；至少他的设计理念很具备前瞻性的，就算是国内这么火的Vue也是借鉴了React来实现的；衍生框架就很多：比如服务端渲染框架的Nextjs，移动端框架的React Native，桌面端框架的Electron等等

**怎么去做webpack打包优化的**

- CSS代码
  - 去除无用CSS，mini-css-extract-plugin和purge-css-plugin
  - 压缩CSS，OptimizeCSSAssetsPlugin
- image代码
  - 小图片可以使用base64的格式，减少请求数
  - 如果支持webp格式，可以尽量使用webp，或者对质量不是很高的可以使用jpg
  - 压缩图片，image-webpack-loader
- JS代码
  - uglifyJS插件，TerSerPlugin性能较好
- 构建优化
  - 使用多线程进行打包，thread-loader
  - 使用持久性缓存，cache-loader、hard-source-webpack-plugin
- 有好日志输出，friendly-errors-webpack-plugin
- 分析打包耗时，speed-measure-webpack-plugin
- 分析文件大小，bundle-anylyzer-webpack-plugin
- 代码分割
  - 多入口
  - 懒加载
  - 按需加载
  - prefetch和preload，前者优先级较低而且是闲时加载，后者则是预先加载，优先级最高。异步/延迟/插入的脚本在网络优先级中算是最低
- 使用CDN
  - 概念：内容分发网络，采用就近原则去请求服务器获取资源。代码分割后，请求数自然就增加，可以使用CDN减少自己服务器的压力
  - 使用持久化缓存，对资源文件进行缓存，资源文件可以通过hash值去刷新清空之前的缓存，拉取最新的文件
  - 并行加载不阻塞，可以分配到不同的CDN服务器
  - 多个域名，可以通过preconnect进行域名预解析，降低域名解析带来的延迟
  - 配置`UploadPlugin`帮你自动发布到CDN上，注意配置`publicPath`字段指定从哪请求资源
- 提取公共代码
  - 提取公共代码
  - 提取第三方代码
- DLL动态链接库
  - DllPlugin和DllDefinePlugin，需要两个配置文件。配置导出对象的名字：library
  - AutodllWebpackPlugin，一个配置文件可以搞定
- 摇树
- 作用域提升
- 缩小查找范围
  - 缩小查找模块的查找范围，resolve
    - 指定扩展名数组
    - 指定模块别名，不用去找
  - 缩小loader的查找范围，resolveLoader
  - 匹配一次loader，oneOf
- 忽略打包
  - 忽略模块，noParse，将会不解析这个模块
  - 忽略目录，IgnorePlugin，将会不打包这些目录
- 配置全局变量，DefinePlugin

**开发模式和生产模式有什么区别**

- 可以通过配置`mode`，或者在命令行中添加配置来指定使用哪个模式。或者使用`cross-env`，通过`definePlugin`来定义一些变量，然后使用`process.env.*`来获取这个变量值，最后指定哪个模式
- 打包结果不一样，由于生产模式会做兼容/优化，所以最终的结果必然会跟源码有些出入
- 开发模式下，可以正常使用日志模块，生产模式就要屏蔽掉
- 开发模式下，source-map可以很完整，但是生产模式最好不要有source-map，特别是嵌入js文件的source-map，这会增加bundle的体积
- 生产模式下，自动开启`tree shaking`、`scop hoiting`等特性
- 开发模式下，devServer会把bundle存到内存中，生产模式下是存到文件目录下
- 你可以给开发模式开启热更新，但生产模式不需要
- 正常项目中，都是一个开发配置和一个生产配置，最后分别合并一个公共的配置来使用

> 题外话：从打包依赖出发，`package.json`中的`dependencies`和`devDependencies`的处理上会有些区别，前者是生产模式依赖，后者是开发模式依赖，可以通过`npm install --production`来只安装生产模式依赖

**Webpack5带来的新特性**

> - 使用持久性缓存来提高构建性能
> - 用更好的算法和默认值来改进长期缓存
> - 更好的Tree Shaking和代码生成来改善包大小
> - 改善与网络平台的兼容性
> - 清理v4那些奇怪状态的内部结构
> - 为未来的功能做准备

- 功能清除

> 清除已废弃的功能

如果需要迁移到Webpack5，确保webpack4运行的构建不会有功能过期警告！

> 不再为NodeJs模块自动引用Polyfills

如果你的项目有引用NodeJs模块，要升级到Webpack5，就要手动添加合适的Polyfills。而对于类库开发者，应该在package.josn中添加

browser字段，使类库在前端能适用

- 长期缓存优化

> 确定的Chunk、模块ID和导出名称

生产模式下默认启用。意味着生成的缓存失效不再频繁

> 真正的contentHash

使用真正的文件内容哈希，也就是说不会把注释和变量重命名计算进去，这对长期缓存会有积极影响

- 更好的开发支持

> 代码块ID命名

开发模式下，默认启用新命名算法，模块ID由其路径决定，代码块ID由代码块的内容决定

> 模块联邦【不是太清楚，好像可以支持从远程构建中导入模块】

多个Webpack构建一起工作。

- 更好的Web平台支持

> JSON模块

要求使用默认导出，未使用的属性会被优化掉（`usedExports`）。自定义JSON解析器，`Rule.parser.parse`指定

> 资源模块【不太清楚，好像只是为了能更好地支持Web平台功能】

对表示资源的模块提供了内置支持。这种“新方式”是为了允许在没有打包工具的情况下运行代码，在浏览器原生ECMAScript模块中使用

`import url from "./image.png"` 和 在`module.rule` 中设置 `type: "asset"`当匹配这样的导入时。(老方法)

`new URL("./image.png", import.meta.url)` (新方式)

> 原生Worker支持【不太清楚，好像只是为了能更好地支持Web平台功能】

> URIs【不太清楚】

支持在请求中处理协议

> 异步模块【不太清楚】

基于异步和Promise来解析异步模块

> 外部资源【不太清楚】

- 全新的Node.js生态特性

支持package.json中的`exports`和`imports`字段

- 开发体验的提升

> 指定构建的目标版本

`target: "node14"`或`target: ["web", "es2020"]`

> 统计

> 进度

`ProgressPlugin`插件，统计编译的进度、入口和依赖等

> 自动添加唯一命名

多个Webpack运行时使用同一个全局变量进行代码块加载，这就会在同一个HTML页面上发生冲突。

> 自动添加公共路径

自动确认`output.publicPath`

> TypeScript类型【不太清楚】

从源码中生成TS类型，并通过npm包暴露它们

- 构建优化

> 更好的Tree Shaking

> 尽量保证开发与生成的一致性问题

开启`sideEffects`优化，可以在开发中更快更容易地发现一些生成模式下出现的问题

> 代码块拆分和模块大小

SplitChunksPlugin默认只有`javascript`大小会被处理，现在可以传递多个值来管理他们例如`webassembly`

....

**dev server如何跑起来的**

> 常用配置项

1. contentBase：告诉服务器从哪里提供静态文件资源，静态资源。默认是当前目录，也可以配cdn路径
2. historyApiFallback：SPA页面有用，它使用H5 History Api，当找不到路由404的时候可以自动指向index.html页面
3. inline：自动刷新
4. hot：启动热更新模块
5. port：端口号

> 原理：开启一个HTTP服务器，监听模式进行构建项目，将Bundle输出到内存，HTTP服务器从内存读取Bundle文件返回给前端，如果监听到文件变化，就重复构建
>
> 可以用来做静态资源的访问和API的代理
>
> ```js
> {
>     devServer:{
>         contentBase:'public',
>         proxy:{
>             '/api':{
>                 target:'http://api.target.com'
>             }
>         }
>     }
> }
> ```

**如何理解flex布局**

- 通过设置`display: flex`，这样的一个弹性盒子被称为容器，容器中的子元素被称为一个项目，这些项目会按照弹性盒子的特性进行分布
- 弹性盒子有一个主轴和交叉轴，可以通过设置`flex-direction`改变主轴的方向，以及起点的位置`reverse`
- `flex-grow`：表示项目的放大比例
- `flex-shrink`：表示项目的缩小比例
- `flex-basic`：表示分配主轴的多余空间
- `flex-wrap`：换行，以及起点的位置`reverve`
- 容器上的属性：
  - **`justify-content`**主轴上的对齐方式，居中（`center`）、左边/右边/两边对齐（`flex-start/end或space-between`）、项目之间平均剩余空间（`space-evenly`）、项目均分剩余空间（这些剩余空间会左右等分在项目两侧）（`space-around`）；
  - **`align-centent`**多根交叉轴上的对齐方式，如果只有一根则不起作用，属性与前面类似，轴线占满交叉轴/每行均分交叉轴高度（`stretch`）；
  - **`align-items`**交叉轴上项目的对齐方式，居中（`center`）、上/下对齐（`flex-start/end`）、基线对齐（`baseline`）、项目未固定高度时占满容器高度/每项占满自己的轴高（`stretch`）
- 项目上的属性：
  - **`align-self`**，与`align-items`类似，设置项目的对齐方式

**HTTP2.0的特性**

- `使用字节传输`，可以节约head里面一些无用的字段，减轻网络带宽的压力
- `多路复用`，连接共享，每个连接可以有多个request
- `header压缩`，使用encoder减少需要传输的header的大小，互相缓存一张表，避免header重复的传输
- `服务端推送`，当你请求index.html时，可以帮你把main.js一起返回，下次请求main.js就可以到缓存里面找

**经验总结**

- 注意细节，回答问题的时候应该要引导面试官往我擅长的领域去问
- 可以给自己思考的时间，然后一次性回答出来，不要断断续续，避免回答着就带偏了
- 不会就不会，不要让面试官问你更加不会的问题，避免带偏面试官，带懵自己
- 