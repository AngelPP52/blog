# 对技术的思考

对技术保有持续的热情，热爱你所做的

对未来充满期待和规划

基础是最重要的，计算机基础，数学能力，能把业务反映到技术上的能力

坚持做某一件事，与一群有趣的人

# 对业务的思考

## 业务逻辑与UI分离

```js
// 常见的业务与UI不分离
/**
	写了一个Card组件，在生命周期中调用根据id获取用户信息的API
*/
// 引出问题：如果需要渲染一个CardList，那么这种业务逻辑就很不合理
// 解决方案
/**
	将UI和业务分离，Card需要的数据由CardList容器去获取
	分离后的代码，Card的UI组件不再被任何业务逻辑干扰
*/
```

常见痛点：

1. 生命周期中包含API相关代码，与UI逻辑耦合到一起
2. 内部使用state导致组件的可扩展性变差

解决以上痛点：

1. 抽离业务逻辑，可以理解为业务逻辑都聚合到一个类里面，无论UI如何改，都不应该影响到业务逻辑，反之亦然
2. 充分利用Redux的特性，将状态和UI设计成可插拔的

## 遇到的挑战的事

**优化体验**

- 业务那边发现的问题：在使用一个表格组件时，切换页面会莫名其妙地卡顿。首先列数就有十几条，而且每次渲染数据量超过300条，这个问题基本是必现的，这就知道应该是数据量太大导致了每次渲染dom和销毁dom都需要比较长的事件

  解决：通过虚拟长列表的方案来解决这个问题的，对整个网站所有不使用分页的表格组件都使用了虚拟长列表

- 业务那边发现的问题：每次操作长列表/目录列表，都是整个组件全量刷新，给人的感觉就是明明其他节点没有操作，却也更新了，效果不好，而且如果列表的内容比较多的时候，就会闪烁

  解决：使用track by，类似react中的key，只更新修改的项目，没有修改的项目不更新

- 大文件上传：在最近的一个项目里面体现到，需要上传媒体资源，在使用没有考虑大文件的api时，经常要很久才响应，有时候还会超时

  解决：采用断点续传，和后台商讨，约定好分片大小，每片的hash信息所有分片上传完毕后进行再合并。因为每次计算文件hash都比较花费事件，所有当时就使用web worker来做这个复杂计算。还可以优化：利用fiber思想，在浏览器空闲阶段去做这个计算。后来我就把这个上传模块做成了一个组件，以后需要到上传大文件的，都可以直接使用这个组件

- 当时需要快速搭建一个新项目，然后排期比较短，新项目的大概配置和使用的组件都跟之前一个旧项目比较类似。

  解决：把旧项目中以后可以公用的模块抽离出来，比如websocket模块，公共组件，工具包，Sass变量表、公共的函数和mixin等。把这些模块打包成动态模块，上传到NPM私库中。以后开始类似的新项目都可以使用这个动态模块，开箱即用

- 业务那边提出的问题：打开网页，首屏响应比较慢。

  解决：1.先采取路由懒加载策略，减少不必要资源请求；2.压缩CSS、js、image，使用tree shaking；3.组件化，减少CSS嵌套；4.使用CSS动画来代替js动画；5.防止阻塞dom，link放到head中，script放到dom下面，使用defer/async；6.使用前端缓存和网络请求缓存；7.cdn预解析/tcp预连接；8.避免复杂计算即长任务；9.配置gzip和http2.0；10.其他编码优化

  观测手段：开发过程使用浏览器performance api，测试过程使用sentry在我的机器中开启了一个sentry服务，然后在测试机器中的网站代码中插入了埋点代码，收集一些前端性能指标，然后再对自己的代码进行评估和优化

  效果：1.请求数从原来的25条减至10条；2.首屏渲染时间从原来的3-5s减至1-2s；3.main.js从原来的3-4m到现在的1-2m；4.首屏几乎没有50ms以上的长任务；5.等等

  思考：感觉自己对浏览器，网络不够熟悉，要花时间熟悉计算机基础，了解低层原理

**统一的风格和操作习惯**

为什么有这样的要求？首先我们的前端项目，有一部分需要参考现在已有的桌面应用来开发的，所以风格和操作习惯不能相差太远。

我是这样做的，使用Sass等预处理器来设计UI主题变量表，然后页面上的样式，都应该沿用这个变量表的属性。然后对组件样式进行重构，使样式和色调基本符合桌面应用

组件化，将操作流程这种逻辑封装起来，其他地方进行复用

**音视频模块**

一套通用的组件库，既可以适应当前版本的机型，也要做到能方便扩展，复用到以后的版本中

定配色，定UI风格，按钮hover/focus/active效果，友好提示，不同颜色表示不同状态值，使用d3封装svg的基本动画（音量滑块/曲线图/动态音量/温度计等），组件化

价值：这个就很大了，首先我们很多设备都有音频模块，所以这些组件基本可以在以后的项目中都能使用到，不用再去造轮子。而且里面设计到比较多计算，这些细节都是开发类似网站不用关心的

## 冗余的工作量

痛点：

1. 惯性思维觉得，按照当前架构一直走到黑就行。除非碰到无法解决的难题，很少思考如何提高代码的维护性、可拓展性、复用性等等
2. 对每天都在重复做的事情，有没有想过可以使用自动化，还是都已经习惯了这样的工作方式。同一件事情，每天都要做，而且每天很多遍，这挺让人窒息的
3. 不同的项目，技术选型完全一致，以比较原始的方式开始一个新项目，拷贝旧项目的package.json依赖和公用逻辑，就直接开始
4. 分层思想没有很好利用，采用的就是传统的mvc分层，但是随着业务复杂起来，controller里面堆积了很多业务逻辑，model堆积了很多转换计算等逻辑（这些逻辑可以被抽离）

解决：

1. 写一个组件的时候，看一下是不是还可以拆分，把业务逻辑和UI抽离，这样不同的项目，至少UI是完全可以复用的。尽量把UI设计成可配置的，渲染组件的数据可以从父容器传递下去；组织好分层结构，代码是否好找？；利用一些规范工具协助你写出规范的代码，eslint，BEM，统一vsCode插件？

2. 重复的工作流：手动使用ng-cli完成构建，等待构建，将构建结果和另外提供的初始化文件一起拷贝到虚拟机中，执行一段脚本，等待压缩和加密完成，将加密后的文件拷贝回本地，通过TFTP发布到设备中的web服务器中。

   解决的手段：改用webpack，可以灵活配置插件，loader，写成一个简易的cli。构建过程和加密工作都在本地机器中完成，webpack需要做的工作有构建项目文件，运行加密插件从配置的目录下读取初始化文件和构建结果一起打包出加密文件。然后使用一个Node包开启一个TFTP client，通过配置的ip，直接发布到设备中。整个流程，都应该在命令行中有所提示，构建完成，加密完成，TFTP发送完成。这就是一键自动完成发布

3. 将公共模块打包成一个lib或者npm包，把这个公共模块做成一个动态模块，新项目去引入这个包，开箱即用

4. controller中耦合了很多业务逻辑的问题：把controler分成UI和service层，service层用来做业务逻辑，UI只关心组件渲染的逻辑（这样UI可以脱离具体业务复用起来）

   model中尽管是使用的是redux，冗余逻辑体现在比如对前端数据结构进行增删改进行更改状态，每个reducer中都在做类似的转换工作：把这种转换逻辑抽象成一个功能函数，放到redux的外部，调用模块中不同的接口做不同的逻辑
   
   相比要求极致性能和交互设计和埋点规范化和监控平台，技术沉淀重要一些，毕竟还不是很大的一个团队，从快准稳到精耕细作更需要一个漫长的过程。更好的架构，组件化，规范化，统一风格，代码审核，把这些做好，才能提高开发的效率
   
   特别是当你被要求做一个不是直接用来卖钱的工具时，到底是做完功能就够了呢，还是思考自己做的模块是否能够抽象成一个公共模块，以后遇到类似的需求，就减少很多工作量
   
   业务线不成熟

思考：写模块时，多考虑复用性，帮助你自己和队友少coding；对于重复的工作流，不能只埋头执行，而要思考如何自动化；多了解软件工程中，设计原则和设计模式，对自己的编码习惯很有帮助，所以我买了一本书《JavaScript设计模式》，在读的过程中，还需要多多实践；

我的价值：对团队的价值，使架构更加健壮，减少没必要的工作量，可以专心解决业务问题，监控工具；对测试团队的价值，使用自动化工具帮助他们完成发布流程和管理不同版本的项目包；对公司的价值，和后台/设备团队一起推动业务的进展，

## 参与业务

性能、交互与风格样式都是需要时刻关注的点

砍需求：有理有据地阻止不合理的需求，将有限的人力、时间花费在更重要的需求上，才能更好地推动业务

## 不只是前端

发挥自己的主观能动性，除了技术之外，要主动去看更多的东西。要弄明白业务提一个需求，这个需求解决了什么问题，涉及到的上下游关系等业务层面的事情

跟后端约定接口，不仅仅是盯着后端给我返回所需的字段就行了。接口是否有可复用性、字段是否冗余、有没有必要做接口拆分或整合、前端保证接口出错的情况下页面仍旧是可被用户接受的

业务提需求，但我们业务不懂技术，这种情况其实很难应付。那就应该拿数据说话，如果你觉得需求一定要砍，使用通俗的话语表达你的意思，以理服人

## 良好心态

我曾经就不爽过设备团队的一个合作伙伴，作为新人直接上手约定协议这种工作，一直在追问让对方不太耐烦。虽然当时完全觉得一心努力做事却受这样的委屈，不过这个不爽很快就消除了（毕竟放弃协商不是解决问题的根本）。我先通过从软件团队我们的老大还有其他做过类似的工作的同事中了解了大概的业务，然后放下身段，以协商口吻与设备团队的伙伴完成了这项工作。当然，你也要提升自己的技术，给团队带来一些效果，别人信任你，这样的交流过程自然也会轻松一些。后来我和他也是会有说有笑的~

## 质量保障

**技术故障/逻辑故障**

技术故障：按钮无效、js报错、接口报错、服务器宕机

逻辑故障：功能表现和执行结果不合逻辑或不符合预期

**内部故障/外部故障**

内部故障：修复职责在己方

外部故障：由其他团队解决

**供应链质量**

CDN、网络、容器、接口、基础框架/库、sdk、打包工具

**做好日志备份**

主动监控：接口、桥方法、业务异常

被动监控：网络/资源时延与成功率、页面性能、js error

对日志进行分类（网络/js/其他）、分级（error/debug/info），把这些日志存储到云端，使用可视化监控平台，可以实时观测日志信息

## 我喜欢什么业务

更喜欢ToC类业务，喜欢大众化的产品，更加考虑体验和用户习惯，在快速迭代中可以快速学到很多东西。想做ToC是觉得，这类产品对年轻人更有吸引力，一部分是热爱，能帮助于思考优化业务，另一部分这是我偏喜欢的挑战类型

现在做的ToB业务，特点就是周期较长，一般分为6个步骤：1.内部需求和立项；2.对供应商初步调查、筛选；3.指定采购指标；4.招标、评标；5.购买承诺；6.安装实施

# 对架构的思考

## 分层架构

> 通过层来隔离不同的关注点，以此应对不同需求的变化，使得这种变化可以独立进行，**即单一职责原则**
>
> 此外，**分层架构模式还是隔离业务复杂度和技术复杂度的利器**

### 经典分层架构

三层架构：用户界面层 ==> 业务逻辑层 ==> 数据访问层 --> 【数据库】

### 领域驱动设计的分层架构

在用户界面层与业务逻辑层之间引入了新的一层，应用层

四层架构：用户界面层 ==> 应用层 ==> 基础设施层（原业务逻辑层） ==> 领域层（原数据访问层） --> 【数据库】

### 分层的原则和依据

原则：“机器为本，用户至上”。分层架构中的层次越往上，越面向业务，面向用户；分层架构中的层次越往下，越面向设备，越通用。**保证同一层的组件处于同一个抽象层次，即单一抽象层次原则**

依据一：基于关注点不同的调用目的划分层次

依据二：面对变化，即严禁层次之间互相干扰，至少将变化对各层带来的影响降到最低

### 层之间的协作

“高层模块不应该依赖于低层模块，二者都应该依赖于抽象”，**即依赖倒置原则**

我们应该依赖不变或稳定的元素（类、模块或层），换句话说，抽象不应该依赖于细节，细节应该依赖于抽象

这一原则实际上是“面向接口设计”原则的体现，高层模块对低层模块的实现是一无所知的

如何将低层具体的实现传递给高层的类？**为了更好地解除高层对低层的依赖，我们往往需要将依赖倒置原则与依赖注入结合起来**，只有运行调用者代码时，才将外面的依赖传递给高层的类

自顶向下：上层对下层的“请求（或调用）”。分层架构中，高层依赖于低层的抽象

自底向上：下层对上传的“通知”。比如观察者模式

无论是自顶向下，还是自底向上，不应该坚持三层架构或四层架构这种固有思维，**而是将分层视为关注点分离的水平抽象层次的体现，过多层会增加不必要开支，过少层导致关注点不够分离，导致系统的结构不合理**

### 如何演进领域驱动架构

技术总是在演进，领域驱动架构亦是如此。。。

# 对企业的思考

热爱这个城市？热爱这个企业，价值观？

认真生活，快乐工作

汇聚了很多优秀的人才，我想和他们一起学习和进步

希望能赚多点钱，让爸妈俩过上好点的生活

# 对自身的思考

多注意自己的技术广度和深度，然后慢慢参与到业务中

前期（0-3年）重心还是技术上，同时应该抬起头关注业务；后期（3年~）就要多思考如何使用技术去支撑业务赋能业务

懂业务的前端更好规划功能

业务的推动固然是靠整个团队在推动的，每个人都出色做好自己的工作，那整个团队的合力才会越大。我希望各自都可以专注于本身的技术，团队的合力才会最大化，如果你是一个大杂烩，做出来的东西也很像一个大杂烩

对业务的思考很有限，无论是公司的局限还是自身的问题，都应该要反思，接下来，应该如何去培养业务思维，如何将自己的技术运用到业务上，这一点很重要

# 总结

ToB业务普遍只要求稳定，比较良好的兼容性。我在里面要做的是，希望能通过网络/打包/编码等手段，去帮助优化网站的性能，使网站趋向于稳定的状态。在编码过程中，经常回头看自己的代码，思考，如何更好做到兼容性，写出扩展性、复用性高的代码，那就去学多一些设计模式/设计原则，找更加适合这套业务的架构和实践方案。为了能看懂别人设计的开源项目，或者深入理解应用的设计，读源码，自己造轮子的过程是必不可少的，而且我也一直尝试和已经落地了部分优秀的实践到目前的架构中，我觉得这些都是很好的一个方向

通过自己学的原理知识，重构代码；写一些自动化工具帮助自己减少发布时间；通过可视化界面帮助业务管理好打包文件的各种版本，可以回退也可以对当时发布的项目有比较清晰的日志记录

抽离公共模块，减轻开始新项目的难度；将核心业务的模块打包成组件库，这样可以在各种项目中共用；

尝试引入前端监控技术，在打包后的代码中插入埋点代码，通过可视化界面和服务存储的方式，把错误信息/渲染阶段各种参数收集起来，通过界面展示出来，这样的好处是，可以实时监控测试那边的的操作，对一些错误可以迅速排查错误，减少解决缺陷过程中还要再问人和再现错误的时间

期待薪资：20k

## 参考

