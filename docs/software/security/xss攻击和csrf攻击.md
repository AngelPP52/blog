### XSS攻击

> 实质：恶意脚本
>
> 往网页插入恶意脚本，当用户真正浏览时，脚本就会执行

#### 存储型

恶意脚本被**保存到服务器的数据库中**，每次从数据库读取到这些脚本，返回给客户端，就会执行恶意脚本，达到攻击效果

例如：评论区

#### 反射型

恶意脚本作为**请求路径的一部分**（参数），服务器拿到这样的参数，然后返回给客户端，就会作为HTMl一部分解析，如果是脚本就直接执行了

例如：`localhost:8080/user?q=<script>alert('你被攻击了')</script>`

与存储型不同的是，反射型不会存储到数据库

#### 文档型

不经过服务器，利用数据传输过程中，劫持并修改html文档（**wifi路由劫持和本地恶意软件**），达到攻击效果

#### 防范

- 永远不要相信用户的输入
- 利用CSP（即浏览器中的内容安全策略）
- XSS攻击一般用来窃取Cookie，所以可以通过HttpOnly，js脚本无法访问document.cookie属性

### CSRF攻击

> 实质：跨站请求伪造
>
> 利用用户的登录状态，跳转到一个新的页面（黑客的页面），进而发起跨站请求

#### 自动发送GET请求

例如：这段代码`<img src="https://xxx.com/info?user=hhh&count=77">`

进入网页后自动发送请求，并且会带上xxx.com的Cookie（如果你已经登录），如果服务器没有验证，就会认为这是一个正常的用户，可以进行敏感操作

#### 自动发送POST请求

例如：一个发送POST请求的表单，和一段自动提交表单的脚本

同上，会携带用户的Cookie信息

#### 诱导点击发送GET请求

例如：一个链接

原理类似自动发送GET请求

#### 防范措施

- 利用Cookie的SameSite属性，防止自动发送目标站点下的Cookie
  - `Strict` - 完全禁止第三方请求携带Cookie，在其他域名下的请求不能携带此Cookie
  - `Lax` - get方法的表单，或者a标签发送get请求时，可以携带Cookie，其他不能
  - `None` - 默认模式，都会带上
- 服务器验证来源站点。通过这两个字段：`Origin`和`Referer`。但两者都能通过Ajax来自定义请求头，伪造假的站点
- `CSRF Token` - 在请求页面时，植入到返回的页面中。下次请求时 ，必须带上这个字符串，来验证来源站点

### XSS与CSRF的区别

XSS会在正常的页面中插入一段恶意脚本。而CSRF不会插入恶意脚本，只是通过有道用户打开第三方网站，并且利用用户的登录状态来发起跨域请求