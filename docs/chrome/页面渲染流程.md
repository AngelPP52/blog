
## DOM（Document Object Model）

> **DOM AST （DOM抽象语法树）**
>
> 	- 不同的elements有不同的JS对象，如`div`会被编译成`HTMLDivElement`
> 	- DOM API并不是JavaScript的标识符，通过DOM API（低级的，Render Tree中的DOM才是高级的），用户可以增加/删除HTML elements，改变它们的外表或者监听他们的事件

## CSSOM（CSS Object Model）

> 可以给HTML elements设置样式，也可以通过css选择器选中DOM，并且修改DOM的样式等
>
> **CSSOM AST（CSSOM抽象语法树）**
>
> - 在构建DOM之后，浏览器会读取所有CSS资源，构建CSSOM
> - 浏览器会使用开发者的样式覆盖用户代理样式`user agent stylesheet`（会由W3CCSS提供默认值）

## Render Tree

> 一棵结合了DOM和CSSOM的树
>
> - 浏览器使用这个Render Tree，计算所有可见elements的layout布局，并且开始绘制到屏幕上，如果Render Tree未构建，在屏幕上是看不到任何东西的
> - Render Tree代表了最终绘制到屏幕上的内容，所以**不包含像素矩阵中的任何区域的节点将不会包含在Render Tree中**，如`display: none`，`尺寸0px * 0px`的elements（这样的孩子节点也同样不会被包含在Render Tree中）。但是设置`visibility: hidden`，`opacity: 0`的elemnts依然会出现在Render Tree中，它们会占有屏幕的一部分区域
> - CSSOM默认是不会暴露给用户API的，但是通过Render Tree是结合DOM和CSSOM的特性，将会为DOM提供更多高级的API，这些API就包含了可以通过修改DOM的CSS属性来修改CSSOM

## How to load a website

```mermaid
graph TB
start(...) --> read_HTML(读取HTML文本) --> buid_DOM(构建DOM树) --> build_RenderTree(构建Render Tree)
read_HTML --> |行内,嵌入,外部CSS|build_CSSOM(构建CSSOM树) --> build_RenderTree --> painting(开始绘制到屏幕)
```

### Layout operation

> 根据Render Tree计算每个节点的layout布局大小（最终绘制到屏幕上的），这个过程也可以成为**回流**，触发回流的情况有以下：滚动，缩放窗口，编辑DOM elements

### Paint operation

> 用户可以使用Render Tree中的DOM elements频繁修改外观、位置或图形属性，为此浏览为其创建了一个**图层**，使网页更高效地执行绘画操作。如滚动时，使用层可以帮助浏览器按照希望的方向（Z轴）正确绘制元素
>
> 拿到图层，开始绘制到屏幕上，每个图层并非绘制到单个图像上，而是分开被绘制，而在每一层上，浏览器会用元素的任何可见属性来填充各个像素，这个过程成为**光栅化**，为了提高性能，光栅化过程使用了不同线程来执行

### Compositing operation

> 在这个阶段，拿到所有的图层，让GPU来进行绘制。然而，尽管绘制以一个图层为单元，但也不会整个图层进行一次性绘制，因为每次回流或重绘都需要消耗很多性能，所以需要把图层分解成一个一个更小的块（pannel），**每次只需要单独绘制一个`pannel`**

以上就是典型的渲染流程

...

更好的用户体验

## Render blocking CSS & DOMContentLoaded

> 浏览器接收到HTML文本后，开始从上倒下构建DOM
>
> 如果遇到嵌入JavaScript和CSS，**会同步进行解析，阻塞下面HTML elements的解析**
>
> 如果遇到`<link ref="stylesheet">`元素，浏览器会发一个**异步请求加载外部CSS，然后继续解析下面的HTML elements**
>
> 如果遇到`<script src="">`元素，浏览器会请求加载外部JavaScript，**DOM构建就会被阻塞进行，直至这段外部JavaScript代码被下载并解析完成**
>
> `DOMContentLoaded [DCL]`事件在**DOM和CSSOM构建完成**并且Render Tree即将被构建完成时触发（外部JavaScript和DOM完全准备好时）
>
> `window.onload [L]`事件在外部CSS和引用的外部静态资源（image）下载完成并且**页面构建完全**后触发（所以window.onload会比DOMContentLoaded需要的时间多）
>
> CSSOM必需等待外部CSS下载并解析完成才能被构建完成，所以外部CSS会阻塞CSSOM的构建（**外部CSS下载是异步非阻塞，但解析是阻塞**），而CSSOM未能构建完成，意味着`DOMContentLoaded`事件也会延迟被触发